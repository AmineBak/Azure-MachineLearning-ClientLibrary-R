options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
print(RJSONIO::toJSON(req))
print(jsonlite::toJSON(req))
body = jsonlite::toJSON(req)
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid to serve as the web service ID
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update)
# Format output
newService <- RJSONIO::fromJSON(h$value())
# Use discovery functions to get endpoints for immediate use
endpoints <- getEndpoints(wkID, authToken, newService["Id"])
# currently returning list of webservice details (as a list) and endpoint details (as a list) in that order
return(list("serviceDetails"=newService, "endpoints"=endpoints))
}
publishWebService("addr", "addr", list("x"="float", "y"="float"), list("z"="float"), myWS, myAuth)
getWebServices("37310abb304e4f56bdb66d279477e0be", "ccfe0f6e9c684345a634bdae0b48c4e9")
webservices <- getWebServices("37310abb304e4f56bdb66d279477e0be", "ccfe0f6e9c684345a634bdae0b48c4e9")
webservices
webservices["Id"]
webservices["Id"][[1]]
webservices[1, "Id"]
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure schema inputted matches function signature
if (length(formals(functionName)) != length(inputSchema)) {
stop(sprintf("Input schema does not contain the proper input. You provided %s inputs and %s were expected",length(inputSchema),length(formals(functionName))), call. = TRUE)
}
inputSchema <- publishPreprocess(inputSchema)
outputSchema <- publishPreprocess(outputSchema)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
print(RJSONIO::toJSON(req))
print(jsonlite::toJSON(req))
body = jsonlite::toJSON(req)
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid to serve as the web service ID
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update)
# Format output
newService <- RJSONIO::fromJSON(h$value())
# Use discovery functions to get endpoints for immediate use
endpoints <- getEndpoints(wkID, authToken, newService[1, "Id"])
# currently returning list of webservice details (as a list) and endpoint details (as a list) in that order
return(list("serviceDetails"=newService, "endpoints"=endpoints))
}
publishWebService("addr", "addr", list("x"="float", "y"="float"), list("z"="float"), myWS, myAuth)
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure schema inputted matches function signature
if (length(formals(functionName)) != length(inputSchema)) {
stop(sprintf("Input schema does not contain the proper input. You provided %s inputs and %s were expected",length(inputSchema),length(formals(functionName))), call. = TRUE)
}
inputSchema <- publishPreprocess(inputSchema)
outputSchema <- publishPreprocess(outputSchema)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
print(RJSONIO::toJSON(req))
print(jsonlite::toJSON(req))
body = jsonlite::toJSON(req)
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid to serve as the web service ID
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update)
# Format output
newService <- jsonlite::fromJSON(h$value())
print(newService)
# Use discovery functions to get endpoints for immediate use
endpoints <- getEndpoints(wkID, authToken, newService[1, "Id"])
# currently returning list of webservice details (as a list) and endpoint details (as a list) in that order
return(list("serviceDetails"=newService, "endpoints"=endpoints))
}
publishWebService("addr", "addr", list("x"="float", "y"="float"), list("z"="float"), myWS, myAuth)
cat({"Name":["addr"],"Type":["Code"],"CodeBundle":{"InputSchema":{"x":{"type":["number"],"format":["float"]},"y":{"type":["number"],"format":["float"]}},"OutputSchema":{"z":{"type":["number"],"format":["float"]}},"Language":["r-3.1-64"],"SourceCode":["inputDF <- maml.mapInputPort(1)\r\noutputDF <- matrix(ncol = 1, nrow = nrow(inputDF))\r\ncolnames(outputDF) <- list(\"z\")\r\noutputDF <- data.frame(outputDF)\r\nfor (file in list.files(\"src\")) {\r\n  if (file == \"6807b3983c6711e5a86d6d6849ad73aa\") {\r\n    load(\"src/6807b3983c6711e5a86d6d6849ad73aa\")\r\n    for (item in names(dependencies)) {\r\n      assign(item, dependencies[[item]])\r\n    }\r\n  }\r\n  else {\r\n    if (!(file %in% installed.packages()[,\"Package\"])) {\r\n      install.packages(paste(\"src\", file, sep=\"/\"), lib=\".\", repos=NULL, verbose=TRUE)\r\n    }\r\n    library(strsplit(file, \"\\\\.\")[[1]][[1]], character.only=TRUE)\r\n  }\r\n}\r\naction <- function (x, y) \r\n{\r\n    return(x + y)\r\n}\r\nfor (i in 1:nrow(inputDF)) {\r\n  outputDF[i,] <- do.call(\"action\", as.list(inputDF[i,]))\r\n}\r\nmaml.mapOutputPort(\"outputDF\")"]}} )
cat("{"Name":["addr"],"Type":["Code"],"CodeBundle":{"InputSchema":{"x":{"type":["number"],"format":["float"]},"y":{"type":["number"],"format":["float"]}},"OutputSchema":{"z":{"type":["number"],"format":["float"]}},"Language":["r-3.1-64"],"SourceCode":["inputDF <- maml.mapInputPort(1)\r\noutputDF <- matrix(ncol = 1, nrow = nrow(inputDF))\r\ncolnames(outputDF) <- list(\"z\")\r\noutputDF <- data.frame(outputDF)\r\nfor (file in list.files(\"src\")) {\r\n  if (file == \"6807b3983c6711e5a86d6d6849ad73aa\") {\r\n    load(\"src/6807b3983c6711e5a86d6d6849ad73aa\")\r\n    for (item in names(dependencies)) {\r\n      assign(item, dependencies[[item]])\r\n    }\r\n  }\r\n  else {\r\n    if (!(file %in% installed.packages()[,\"Package\"])) {\r\n      install.packages(paste(\"src\", file, sep=\"/\"), lib=\".\", repos=NULL, verbose=TRUE)\r\n    }\r\n    library(strsplit(file, \"\\\\.\")[[1]][[1]], character.only=TRUE)\r\n  }\r\n}\r\naction <- function (x, y) \r\n{\r\n    return(x + y)\r\n}\r\nfor (i in 1:nrow(inputDF)) {\r\n  outputDF[i,] <- do.call(\"action\", as.list(inputDF[i,]))\r\n}\r\nmaml.mapOutputPort(\"outputDF\")"]}} ")
cat("{\n \"Name\": \"addr\",\n\"Type\": \"Code\",\n\"CodeBundle\": {\n \"InputSchema\": {\n \"x\": {\n \"type\": \"number\",\n\"format\": \"float\" \n},\n\"y\": {\n \"type\": \"number\",\n\"format\": \"float\" \n} \n},\n\"OutputSchema\": {\n \"z\": {\n \"type\": \"number\",\n\"format\": \"float\" \n} \n},\n\"Language\": \"r-3.1-64\",\n\"SourceCode\": \"inputDF <- maml.mapInputPort(1)\\r\\noutputDF <- matrix(ncol = 1, nrow = nrow(inputDF))\\r\\ncolnames(outputDF) <- list(\\\"z\\\")\\r\\noutputDF <- data.frame(outputDF)\\r\\nfor (file in list.files(\\\"src\\\")) {\\r\\n  if (file == \\\"6807b3983c6711e5a86d6d6849ad73aa\\\") {\\r\\n    load(\\\"src/6807b3983c6711e5a86d6d6849ad73aa\\\")\\r\\n    for (item in names(dependencies)) {\\r\\n      assign(item, dependencies[[item]])\\r\\n    }\\r\\n  }\\r\\n  else {\\r\\n    if (!(file %in% installed.packages()[,\\\"Package\\\"])) {\\r\\n      install.packages(paste(\\\"src\\\", file, sep=\\\"/\\\"), lib=\\\".\\\", repos=NULL, verbose=TRUE)\\r\\n    }\\r\\n    library(strsplit(file, \\\"\\\\\\\\.\\\")[[1]][[1]], character.only=TRUE)\\r\\n  }\\r\\n}\\r\\naction <- function (x, y) \\r\\n{\\r\\n    return(x + y)\\r\\n}\\r\\nfor (i in 1:nrow(inputDF)) {\\r\\n  outputDF[i,] <- do.call(\\\"action\\\", as.list(inputDF[i,]))\\r\\n}\\r\\nmaml.mapOutputPort(\\\"outputDF\\\")\" \n} \n}")
?jsonlite::toJSON
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure schema inputted matches function signature
if (length(formals(functionName)) != length(inputSchema)) {
stop(sprintf("Input schema does not contain the proper input. You provided %s inputs and %s were expected",length(inputSchema),length(formals(functionName))), call. = TRUE)
}
inputSchema <- publishPreprocess(inputSchema)
outputSchema <- publishPreprocess(outputSchema)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
print(RJSONIO::toJSON(req))
print(jsonlite::toJSON(req))
body = gsub("\"", "\\\"", jsonlite::toJSON(req))
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid to serve as the web service ID
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update)
# Format output
newService <- jsonlite::fromJSON(h$value())
print(newService)
# Use discovery functions to get endpoints for immediate use
endpoints <- getEndpoints(wkID, authToken, newService[1, "Id"])
# currently returning list of webservice details (as a list) and endpoint details (as a list) in that order
return(list("serviceDetails"=newService, "endpoints"=endpoints))
}
publishWebService("addr", "addr", list("x"="float", "y"="float"), list("z"="float"), myWS, myAuth)
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure schema inputted matches function signature
if (length(formals(functionName)) != length(inputSchema)) {
stop(sprintf("Input schema does not contain the proper input. You provided %s inputs and %s were expected",length(inputSchema),length(formals(functionName))), call. = TRUE)
}
inputSchema <- publishPreprocess(inputSchema)
outputSchema <- publishPreprocess(outputSchema)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
print(RJSONIO::toJSON(req))
print(gsub("\"", "\\\"", jsonlite::toJSON(req)))
body = gsub("\"", "\\\"", jsonlite::toJSON(req))
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid to serve as the web service ID
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update)
# Format output
newService <- jsonlite::fromJSON(h$value())
print(newService)
# Use discovery functions to get endpoints for immediate use
endpoints <- getEndpoints(wkID, authToken, newService[1, "Id"])
# currently returning list of webservice details (as a list) and endpoint details (as a list) in that order
return(list("serviceDetails"=newService, "endpoints"=endpoints))
}
publishWebService("addr", "addr", list("x"="float", "y"="float"), list("z"="float"), myWS, myAuth)
?toStrong
?toString
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure schema inputted matches function signature
if (length(formals(functionName)) != length(inputSchema)) {
stop(sprintf("Input schema does not contain the proper input. You provided %s inputs and %s were expected",length(inputSchema),length(formals(functionName))), call. = TRUE)
}
inputSchema <- publishPreprocess(inputSchema)
outputSchema <- publishPreprocess(outputSchema)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
print(gsub("\"", "\\\"", toString(jsonlite::toJSON(req))))
body = gsub("\"", "\\\"", jsonlite::toJSON(req))
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid to serve as the web service ID
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update)
# Format output
newService <- jsonlite::fromJSON(h$value())
print(newService)
# Use discovery functions to get endpoints for immediate use
endpoints <- getEndpoints(wkID, authToken, newService[1, "Id"])
# currently returning list of webservice details (as a list) and endpoint details (as a list) in that order
return(list("serviceDetails"=newService, "endpoints"=endpoints))
}
publishWebService("addr", "addr", list("x"="float", "y"="float"), list("z"="float"), myWS, myAuth)
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure schema inputted matches function signature
if (length(formals(functionName)) != length(inputSchema)) {
stop(sprintf("Input schema does not contain the proper input. You provided %s inputs and %s were expected",length(inputSchema),length(formals(functionName))), call. = TRUE)
}
inputSchema <- publishPreprocess(inputSchema)
outputSchema <- publishPreprocess(outputSchema)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
print(gsub("\"", "\\\"", toString(jsonlite::toJSON(req))))
body = gsub("\"", "\\\"", toString(jsonlite::toJSON(req)))
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid to serve as the web service ID
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update)
# Format output
newService <- jsonlite::fromJSON(h$value())
print(newService)
# Use discovery functions to get endpoints for immediate use
endpoints <- getEndpoints(wkID, authToken, newService[1, "Id"])
# currently returning list of webservice details (as a list) and endpoint details (as a list) in that order
return(list("serviceDetails"=newService, "endpoints"=endpoints))
}
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure schema inputted matches function signature
if (length(formals(functionName)) != length(inputSchema)) {
stop(sprintf("Input schema does not contain the proper input. You provided %s inputs and %s were expected",length(inputSchema),length(formals(functionName))), call. = TRUE)
}
inputSchema <- publishPreprocess(inputSchema)
outputSchema <- publishPreprocess(outputSchema)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSchema,
"OutputSchema" = outputSchema,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), paste(sprintf("\"%s\"", names(outputSchema)), collapse=","), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
print(gsub("\"", "\\\"", toString(jsonlite::toJSON(req))))
body = gsub("\"", "\\\"", toString(jsonlite::toJSON(req)))
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid to serve as the web service ID
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update)
# Format output
newService <- jsonlite::fromJSON(h$value())
print(newService)
# Use discovery functions to get endpoints for immediate use
endpoints <- getEndpoints(wkID, authToken, newService[1, "Id"])
# currently returning list of webservice details (as a list) and endpoint details (as a list) in that order
return(list("serviceDetails"=newService, "endpoints"=endpoints))
}
publishWebService("addr", "addr", list("x"="float", "y"="float"), list("z"="float"), myWS, myAuth)
cat("{\"Name\":[\"addr\"],\"Type\":[\"Code\"],\"CodeBundle\":{\"InputSchema\":{\"x\":{\"type\":[\"number\"],\"format\":[\"float\"]},\"y\":{\"type\":[\"number\"],\"format\":[\"float\"]}},\"OutputSchema\":{\"z\":{\"type\":[\"number\"],\"format\":[\"float\"]}},\"Language\":[\"r-3.1-64\"],\"SourceCode\":[\"inputDF <- maml.mapInputPort(1)\\r\\noutputDF <- matrix(ncol = 1, nrow = nrow(inputDF))\\r\\ncolnames(outputDF) <- list(\\\"z\\\")\\r\\noutputDF <- data.frame(outputDF)\\r\\nfor (file in list.files(\\\"src\\\")) {\\r\\n  if (file == \\\"92040d763c6811e5a86d6d6849ad73aa\\\") {\\r\\n    load(\\\"src/92040d763c6811e5a86d6d6849ad73aa\\\")\\r\\n    for (item in names(dependencies)) {\\r\\n      assign(item, dependencies[[item]])\\r\\n    }\\r\\n  }\\r\\n  else {\\r\\n    if (!(file %in% installed.packages()[,\\\"Package\\\"])) {\\r\\n      install.packages(paste(\\\"src\\\", file, sep=\\\"/\\\"), lib=\\\".\\\", repos=NULL, verbose=TRUE)\\r\\n    }\\r\\n    library(strsplit(file, \\\"\\\\\\\\.\\\")[[1]][[1]], character.only=TRUE)\\r\\n  }\\r\\n}\\r\\naction <- function (x, y) \\r\\n{\\r\\n    return(x + y)\\r\\n}\\r\\nfor (i in 1:nrow(inputDF)) {\\r\\n  outputDF[i,] <- do.call(\\\"action\\\", as.list(inputDF[i,]))\\r\\n}\\r\\nmaml.mapOutputPort(\\\"outputDF\\\")\"]}}")
myAuth
myWS
gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
jsonlite::toJSON(list("Type"="Code"))
jsonlite::toJSON("Type"="Code")
jsonlite::toJSON(Code")
jsonlite::toJSON(Code")
jsonlite::toJSON("Code")
?jsonlite::toJSON
jsonlite::toJSON(list("Type"="Code"), simplifyVector=TRUE)
jsonlite::toJSON(list("Type"="Code"), flatten=TRUE)
jsonlite::toJSON(list("Type"="Code"), pretty=TRUE)
df <- data.frame(name=c("a", "b", "c"), x=c(NA, 2 ,3), y=c(10, 20, -Inf), show=c(TRUE, FALSE, TRUE))
df2json(df)
library(df2json)
df <- data.frame(name=c("a", "b", "c"), x=c(NA, 2 ,3), y=c(10, 20, -Inf), show=c(TRUE, FALSE, TRUE))
df2json(df)
