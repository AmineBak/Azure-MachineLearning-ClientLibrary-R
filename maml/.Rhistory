numParamsEXPECTED <- length(formals(funcName))
numParamsPASSED <- nrow(userInput)
if (numParamsPASSED != numParamsEXPECTED) {
errorWarning <- paste("Error: Your input Schema does not contain the proper input. You provided ", numParamsPASSED," inputs and ", numParamsEXPECTED," were expected",sep="")
stop(errorWarning, call. = TRUE)
return(FALSE)
}
else {
return(TRUE)
}
}
publishWebService("add", "serialize", list("arg1"="int"), list("out1"="int"), wsID, auth)
################################################################
# This is a helper function to ensure that the inputSchema has recieved all of the expected parameters
################################################################
#' @param userInput - List of expected input parameters
#' @param funcName - The function that is being published
#' @return False if the input was not as expected/True if input matched expectation
paramCheck <- function(userInput, funcName) {
numParamsEXPECTED <- length(formals(funcName))
numParamsPASSED <- length(userInput)
if (numParamsPASSED != numParamsEXPECTED) {
errorWarning <- paste("Error: Your input Schema does not contain the proper input. You provided ", numParamsPASSED," inputs and ", numParamsEXPECTED," were expected",sep="")
stop(errorWarning, call. = TRUE)
return(FALSE)
}
else {
return(TRUE)
}
}
publishWebService("add", "serialize", list("arg1"="int"), list("out1"="int"), wsID, auth)
library(codetools)
publishWebService("add", "serialize", list("arg1"="int"), list("out1"="int"), wsID, auth)
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure input schema matches function signature
paramCheck(inputSchema, functionName)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
# Probably a more elegant way to do this
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSerialized,
"OutputSchema" = outputSerialized,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(outputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\ninstall.packages(paste(\"src\", \"codetools.zip\", sep=\"/\"), lib = \".\", repos=NULL)\r\nlibrary(\"codetools\")\r\noutputDF <- data.frame(findGlobals(findGlobals))\r\nmaml.mapOutputPort(\"outputDF\")",
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\noutputDF <- data.frame(list.files(\"src\"))\r\nmaml.mapOutputPort(\"outputDF\")",
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
# TODO: consolidate json packages, i.e. use only one if possible
body = RJSONIO::toJSON(req)
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update,
ssl.verifyhost = FALSE) ### REMOVE THIS FOR THE REAL VERSION ###
# return everything
# TODO: format output
return(RJSONIO::h$value())
}
publishWebService("add", "serialize", list("arg1"="int"), list("out1"="int"), wsID, auth)
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure input schema matches function signature
paramCheck(inputSchema, functionName)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
# Probably a more elegant way to do this
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSerialized,
"OutputSchema" = outputSerialized,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(outputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\ninstall.packages(paste(\"src\", \"codetools.zip\", sep=\"/\"), lib = \".\", repos=NULL)\r\nlibrary(\"codetools\")\r\noutputDF <- data.frame(findGlobals(findGlobals))\r\nmaml.mapOutputPort(\"outputDF\")",
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\noutputDF <- data.frame(list.files(\"src\"))\r\nmaml.mapOutputPort(\"outputDF\")",
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
# TODO: consolidate json packages, i.e. use only one if possible
body = RJSONIO::toJSON(req)
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update,
ssl.verifyhost = FALSE) ### REMOVE THIS FOR THE REAL VERSION ###
# return everything
# TODO: format output
return(RJSONIO::fromJSON(h$value()))
}
publishWebService("add", "serialize", list("arg1"="int"), list("out1"="int"), wsID, auth)
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure input schema matches function signature
paramCheck(inputSchema, functionName)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
# Probably a more elegant way to do this
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = inputSerialized,
"OutputSchema" = outputSerialized,
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(outputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\ninstall.packages(paste(\"src\", \"codetools.zip\", sep=\"/\"), lib = \".\", repos=NULL)\r\nlibrary(\"codetools\")\r\noutputDF <- data.frame(findGlobals(findGlobals))\r\nmaml.mapOutputPort(\"outputDF\")",
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\noutputDF <- data.frame(list.files(\"src\"))\r\nmaml.mapOutputPort(\"outputDF\")",
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
# TODO: consolidate json packages, i.e. use only one if possible
body = RJSONIO::toJSON(req)
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update,
ssl.verifyhost = FALSE) ### REMOVE THIS FOR THE REAL VERSION ###
# return everything
# TODO: format output
newService <- RJSONIO::fromJSON(h$value())
# switch to getEndpoints() later
defaultEP <- getEndpointsT(wkID, authToken, newService["Id"])
return(defaultEP)
}
publishWebService("predictTitanic", "TitanicDemo", list("Pclass"="int", "Sex"="string", "Age"="int", "SibSp"="int", "Parch"="int", "Fare"="int"), list("score"="float"), wsID, auth)
library(functional)
?Curry
test <- function(x) {
argList <- list()
for (name in names(x)) {
argList <- c(argList, name)
}
return(argList)
}
test(list("arg1"="int"))
names(list("arg1"="int"))
names(list("arg1"="int", "arg2"="float"))
typeof(names(list("arg1"="int", "arg2"="float")))
as.list(names(list("arg1"="int", "arg2"="float")))
as.list(names(list("arg1"="int", "arg2"="float")))[[1]]
as.list(names(list("arg1"="int", "arg2"="float")))[[2]]
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure input schema matches function signature
paramCheck(inputSchema, functionName)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
# Probably a more elegant way to do this
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(inputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(outputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\ninstall.packages(paste(\"src\", \"codetools.zip\", sep=\"/\"), lib = \".\", repos=NULL)\r\nlibrary(\"codetools\")\r\noutputDF <- data.frame(findGlobals(findGlobals))\r\nmaml.mapOutputPort(\"outputDF\")",
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\noutputDF <- data.frame(list.files(\"src\"))\r\nmaml.mapOutputPort(\"outputDF\")",
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
# TODO: consolidate json packages, i.e. use only one if possible
body = RJSONIO::toJSON(req)
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update,
ssl.verifyhost = FALSE) ### REMOVE THIS FOR THE REAL VERSION ###
# return everything
# TODO: format output
newService <- RJSONIO::fromJSON(h$value())
# Use discovery functions to get default endpoint for immediate use
# switch to getEndpoints() later
defaultEP <- getEndpointsT(wkID, authToken, newService["Id"])
# Curry relevant parameters to consumption function
consumption <- Curry(ConsumeSingleRequest, "api_key"=defaultEP[[1]]["PrimaryKey"], "URL"=paste(endpoint[[1]]["ApiLocation"],"/execute?api-version=2.0&details=true",sep=""), columnNames=as.list(names(inputSchema)))
# what to return? Web service? Default endpoint? Consumption function?
return(consumption)
}
publishWebService("predictTitanic", "TitanicDemo", list("Pclass"="int", "Sex"="string", "Age"="int", "SibSp"="int", "Parch"="int", "Fare"="int"), list("score"="float"), wsID, auth)
test <- publishWebService("predictTitanic", "TitanicDemo", list("Pclass"="int", "Sex"="string", "Age"="int", "SibSp"="int", "Parch"="int", "Fare"="int"), list("score"="float"), wsID, auth)
consume(list(1, "male", 20, 1, 0, 8))
test(list(1, "male", 20, 1, 0, 8))
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure input schema matches function signature
paramCheck(inputSchema, functionName)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
# Probably a more elegant way to do this
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(inputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(outputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\ninstall.packages(paste(\"src\", \"codetools.zip\", sep=\"/\"), lib = \".\", repos=NULL)\r\nlibrary(\"codetools\")\r\noutputDF <- data.frame(findGlobals(findGlobals))\r\nmaml.mapOutputPort(\"outputDF\")",
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\noutputDF <- data.frame(list.files(\"src\"))\r\nmaml.mapOutputPort(\"outputDF\")",
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
# TODO: consolidate json packages, i.e. use only one if possible
body = RJSONIO::toJSON(req)
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update,
ssl.verifyhost = FALSE) ### REMOVE THIS FOR THE REAL VERSION ###
# return everything
# TODO: format output
newService <- RJSONIO::fromJSON(h$value())
# Use discovery functions to get default endpoint for immediate use
# switch to getEndpoints() later
defaultEP <- getEndpointsT(wkID, authToken, newService["Id"])
# Curry relevant parameters to consumption function
consumption <- Curry(consumeSingleRequest, "api_key"=defaultEP[[1]]["PrimaryKey"], "URL"=paste(endpoint[[1]]["ApiLocation"],"/execute?api-version=2.0&details=true",sep=""), columnNames=as.list(names(inputSchema)))
# what to return? Web service? Default endpoint? Consumption function?
return(consumption)
}
test <- publishWebService("predictTitanic", "TitanicDemo", list("Pclass"="int", "Sex"="string", "Age"="int", "SibSp"="int", "Parch"="int", "Fare"="int"), list("score"="float"), wsID, auth)
test(list(1, "male", 20, 1, 0, 8))
test(list(1, "male", 20, 1, 0, 8))
publishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {
# Make sure input schema matches function signature
paramCheck(inputSchema, functionName)
# Accept SSL certificates issued by public Certificate Authorities
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
# Get and encode the dependencies
zipString = packDependencies(functionName)
# Build the body of the request, differing on whether or not there is a zip to upload
# Probably a more elegant way to do this
if (zipString[[2]] == "") {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(inputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))
)
)
}
else {
req = list(
"Name" = serviceName,
"Type" = "Code",
"CodeBundle" = list(
"InputSchema" = convert(inputSchema),
"OutputSchema" = convert(outputSchema),
"Language" = "r-3.1-64",
"SourceCode" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\ninstall.packages(paste(\"src\", \"codetools.zip\", sep=\"/\"), lib = \".\", repos=NULL)\r\nlibrary(\"codetools\")\r\noutputDF <- data.frame(findGlobals(findGlobals))\r\nmaml.mapOutputPort(\"outputDF\")",
#        "SourceCode" = "inputDF <- maml.mapInputPort(1)\r\noutputDF <- data.frame(list.files(\"src\"))\r\nmaml.mapOutputPort(\"outputDF\")",
"ZipContents" = zipString[[2]]
)
)
}
# convert the payload to JSON as expected by API
# TODO: consolidate json packages, i.e. use only one if possible
body = RJSONIO::toJSON(req)
# Response gatherer
h = RCurl::basicTextGatherer()
h$reset()
# Generate unique guid
guid = gsub("-", "", uuid::UUIDgenerate(use.time=TRUE))
# API call
RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above
httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),
'Content-Type' = 'application/json',
'Accept' = 'application/json'),
content = body,
writefunction = h$update,
ssl.verifyhost = FALSE) ### REMOVE THIS FOR THE REAL VERSION ###
# return everything
# TODO: format output
newService <- RJSONIO::fromJSON(h$value())
# Use discovery functions to get default endpoint for immediate use
# switch to getEndpoints() later
defaultEP <- getEndpointsT(wkID, authToken, newService["Id"])
# Curry relevant parameters to consumption function
consumption <- Curry(consumeSingleRequest, "api_key"=defaultEP[[1]]["PrimaryKey"], "URL"=paste(defaultEP[[1]]["ApiLocation"],"/execute?api-version=2.0&details=true",sep=""), columnNames=as.list(names(inputSchema)))
# what to return? Web service? Default endpoint? Consumption function?
return(consumption)
}
test <- publishWebService("predictTitanic", "TitanicDemo", list("Pclass"="int", "Sex"="string", "Age"="int", "SibSp"="int", "Parch"="int", "Fare"="int"), list("score"="float"), wsID, auth)
test(list(1, "male", 20, 1, 0, 8))
test(list(1, "male", 20, 1, 0, 8), list(2, "female", 20, 1, 0, 8))
consumeSingleRequest <- function(api_key, URL, columnNames, ...) {
# Accept SSL certificates issued by public Certificate Authorities
values = output_list <- lapply(X=list(...), function(x) x)
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
h = basicTextGatherer()
hdr = basicHeaderGatherer()
req = list(
Inputs = list(
input1 = list(
ColumnNames = columnNames,
Values = values
)
)
)
body = enc2utf8(toJSON(req))
authz_hdr = paste('Bearer', api_key, sep=' ')
h$reset()
curlPerform(url = URL,
httpheader=c('Content-Type' = "application/json", 'Authorization' = authz_hdr),
postfields=body,
writefunction = h$update,
headerfunction = hdr$update,
verbose = TRUE,
ssl.verifypeer = FALSE,
ssl.verifyhost = FALSE
)
headers = hdr$value()
httpStatus = headers["status"]
if (httpStatus >= 400)
{
print(paste("The request failed with status code:", httpStatus, sep=" "))
# Print the headers - they include the request ID and the timestamp, which are useful for debugging the failure
print("headers:")
print(headers)
}
result = fromJSON(h$value())
return(result)
}
results <- test(list(1, "male", 20, 1, 0, 8), list(2, "female", 20, 1, 0, 8))
results
results$Results$output1$value
typeof(results$Results$output1$value)
typeof(results$Results$output1$value$Values)
results$Results$output1$value$Values
as.list(results$Results$output1$value$Values)
consumeSingleRequest <- function(api_key, URL, columnNames, ...) {
# Accept SSL certificates issued by public Certificate Authorities
values = output_list <- lapply(X=list(...), function(x) x)
options(RCurlOptions = list(cainfo = system.file("CurlSSL", "cacert.pem", package = "RCurl")))
h = basicTextGatherer()
hdr = basicHeaderGatherer()
req = list(
Inputs = list(
input1 = list(
ColumnNames = columnNames,
Values = values
)
)
)
body = enc2utf8(toJSON(req))
authz_hdr = paste('Bearer', api_key, sep=' ')
h$reset()
curlPerform(url = URL,
httpheader=c('Content-Type' = "application/json", 'Authorization' = authz_hdr),
postfields=body,
writefunction = h$update,
headerfunction = hdr$update,
verbose = TRUE,
ssl.verifypeer = FALSE,
ssl.verifyhost = FALSE
)
headers = hdr$value()
httpStatus = headers["status"]
if (httpStatus >= 400)
{
print(paste("The request failed with status code:", httpStatus, sep=" "))
# Print the headers - they include the request ID and the timestamp, which are useful for debugging the failure
print("headers:")
print(headers)
}
result = fromJSON(h$value())
values = as.list(result$Results$output1$value$Values)
return(list(values, result))
}
results <- test(list(1, "male", 20, 1, 0, 8), list(2, "female", 20, 1, 0, 8))
results
test(list(1, "male", 20, 1, 0, 8), list(2, "female", 20, 1, 0, 8))
test <- publishWebService("predictTitanic", "TitanicDemo", list("Pclass"="int", "Sex"="string", "Age"="int", "SibSp"="int", "Parch"="int", "Fare"="int"), list("score"="float"), wsID, auth)
test[[3]](list(1, "male", 20, 1, 0, 8), list(2, "female", 20, 1, 0, 8))
test(list(1, "male", 20, 1, 0, 8), list(2, "female", 20, 1, 0, 8))
