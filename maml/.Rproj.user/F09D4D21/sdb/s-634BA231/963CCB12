{
    "contents" : "# strings for navigating\npublishURL <- \"https://hiteshsm.cloudapp.net/workspaces/%s/webservices/%s\" ## REMOVE SSL IGNORING FOR REAL VERSION ##\nwrapper <- \"inputDF <- maml.mapInputPort(1)\\r\\noutputDF <- data.frame(matrix(ncol = %s, nrow = nrow(inputDF)))\\r\\nfor (file in list.files(\\\"src\\\")) {\\r\\n  if (file == \\\"%s\\\") {\\r\\n    load(\\\"src/%s\\\")\\r\\n    for (item in names(dependencies)) {\\r\\n      assign(item, dependencies[[item]])\\r\\n    }\\r\\n  }\\r\\n  else {\\r\\n    if (!(file %%in%% installed.packages()[,\\\"Package\\\"])) {\\r\\n      install.packages(paste(\\\"src\\\", file, sep=\\\"/\\\"), lib=\\\".\\\", repos=NULL, verbose=TRUE)\\r\\n    }\\r\\n    library(strsplit(file, \\\"\\\\\\\\.\\\")[[1]][[1]], character.only=TRUE)\\r\\n  }\\r\\n}\\r\\naction <- %s\\r\\n  for (i in 1:nrow(inputDF)) {\\r\\n    outputDF[i,] <- do.call(\\\"action\\\", as.list(inputDF[i,]))\\r\\n  }\\r\\nmaml.mapOutputPort(\\\"outputDF\\\")\"\n\n##################################################################################\n# WRAPPER TESTING\n# Consider: assert statements (stopifnot), error handling\n# wrap in a function that will return a string with the proper function\n##################################################################################\n# get the input\ninputDF <- maml.mapInputPort(1)\n\n# initialize an empty output dataframe of desired dimensions\noutputDF <- data.frame(matrix(ncol = \"%s\", nrow = nrow(inputDF)))\n\nfor (file in list.files(\"src\")) {\n  if (file == \"%s\") {\n    load(\"src/%s\")\n    # assert that dependencies exists?\n    # NOTE: depedencies object comes from packDependencies(), maybe something more unique to avoid collisions?\n    for (item in names(dependencies)) {\n      assign(item, dependencies[[item]])\n    }\n  }\n  else {\n    # if the package isn't installed on Azure already, install it and its dependencies\n    # need to recursively grab dependencies\n    if (!(file %in% installed.packages()[,\"Package\"])) {\n      install.packages(paste(\"src\", file, sep=\"/\"), lib= \".\", repos=NULL, verbose=TRUE)\n    }\n    # load the package\n    library(strsplit(file, \"\\\\.\")[[1]][[1]], character.only=TRUE)\n  }\n}\n\n# user function\naction <-\n\n# apply function to every row\nfor (i in 1:nrow(inputDF)) {\n  outputDF[i,] <- do.call(\"action\", as.list(inputDF[i,]))\n}\n\n# return output\nmaml.mapOutputPort(\"outputDF\")\n\n# test function\nadd <- function(x) {\n  print(findGlobals(add))\n  return(x+a[[1]])\n}\n\n\n\n################################################################\n# GET THE FUNCTION SOURCE CODE AS A STRING\n# Return the function as a string\n# Also consider paste(body(fun())) or getAnywhere()\n################################################################\ngetFunctionString <- function (x)\n{\n  if (tryCatch(!is.character(x), error = function(e) TRUE))\n    x <- as.character(substitute(x))\n  objs <- list()\n  where <- character()\n  visible <- logical()\n  if (length(pos <- find(x, numeric = TRUE))) {\n    objs <- lapply(pos, function(pos, x) get(x, pos = pos),\n                   x = x)\n    where <- names(pos)\n    visible <- rep.int(TRUE, length(pos))\n  }\n  if (length(grep(\".\", x, fixed = TRUE))) {\n    np <- length(parts <- strsplit(x, \".\", fixed = TRUE)[[1L]])\n    for (i in 2:np) {\n      gen <- paste(parts[1L:(i - 1)], collapse = \".\")\n      cl <- paste(parts[i:np], collapse = \".\")\n      if (gen == \"\" || cl == \"\")\n        next\n      Call <- substitute(getS3method(gen, cl, TRUE), list(gen = gen,\n                                                          cl = cl))\n      f <- eval.parent(Call)\n      if (!is.null(f) && !is.null(environment(f))) {\n        ev <- topenv(environment(f), baseenv())\n        nmev <- if (isNamespace(ev))\n          getNamespaceName(ev)\n        else NULL\n        objs <- c(objs, f)\n        msg <- paste(\"registered S3 method for\", gen)\n        if (!is.null(nmev))\n          msg <- paste(msg, \"from namespace\", nmev)\n        where <- c(where, msg)\n        visible <- c(visible, FALSE)\n      }\n    }\n  }\n  for (i in loadedNamespaces()) {\n    ns <- asNamespace(i)\n    if (exists(x, envir = ns, inherits = FALSE)) {\n      f <- get(x, envir = ns, inherits = FALSE)\n      objs <- c(objs, f)\n      where <- c(where, paste(\"namespace\", i, sep = \":\"))\n      visible <- c(visible, FALSE)\n    }\n  }\n  ln <- length(objs)\n  dups <- rep.int(FALSE, ln)\n  if (ln > 1L)\n    for (i in 2L:ln) for (j in 1L:(i - 1L)) if (identical(objs[[i]],\n                                                          objs[[j]], ignore.environment = TRUE)) {\n      dups[i] <- TRUE\n      break\n    }\n  res <- list(name = x, objs = objs, where = where, visible = visible,\n              dups = dups)\n  class(res) <- \"getAnywhere\"\n\n  #don't show the full response!\n  #res\n  return(gsub(\"\\n\", \"\\r\\n\", gsub(\"\\\"\", \"\\\\\\\"\", objs)))\n}\n\n\n\n##################################################################################\n# EXTRACT DEPENDENCIES\n# Takes closure, not string\n##################################################################################\npackDependencies <- function(funName) {\n  dependencies = list()\n  packages = list()\n\n  # generate a GUID to act as a file name to store packages, R data\n  guid = gsub(\"-\", \"\", uuid::UUIDgenerate(use.time=TRUE))\n\n  # NOTE: will not work if the user function specifies the names directly, e.g. won't find rjson::toJSON\n  # from findGlobals man page: \"R semantics only allow variables that might be local to be identified\"\n  # CONSIDER: how robust is this filtering? need to verify\n  for (obj in codetools::findGlobals(get(funName))) {\n    name = get(obj)\n\n    # filter out primitives\n    if (is.primitive(name)) {\n        next\n    }\n\n    # get objects\n    else if (!is.function(name)) {\n      dependencies[[obj]] <- name\n    }\n\n    # grab user defined functions\n    else if (identical(environment(name), globalenv())) {\n      dependencies[[obj]] <- name\n    }\n\n    # get the names of packages of package functions\n    else if (paste(getNamespaceName(environment(name))) != \"base\") {\n      packages[[obj]] <- getNamespaceName(environment(name))\n    }\n\n    # need an else branch?\n  }\n\n  # save current path to restore to later\n  start = getwd()\n  # go to package library, doing this to prevent tarballing entire path to package\n  # TODO: what if packages are in different library directories? need to iterate through all paths\n  setwd(.libPaths()[[1]])\n  # list of things to include in aggregate .zip\n  toZip = vector()\n  # pack up each package in its own zip (.zip)\n  for (pkg in packages) {\n    # should error handle, e.g. if can't find package\n    zip(paste(start, paste(pkg, \"zip\", sep=\".\"), sep=\"/\"), pkg)\n    toZip <- c(toZip, paste(pkg, \"zip\", sep=\".\"))\n  }\n  # go back to where the user started\n  setwd(start)\n\n  # objects, functions, etc.\n  if (length(dependencies) > 0) {\n    # maybe can save directly as a .zip and skip the zip() call?\n    save(dependencies, file=guid)\n    toZip <- c(toZip, guid)\n  }\n\n  # zip up everything\n  if (length(toZip) > 0) {\n    zip(zipfile=guid, files=toZip)\n    zipEnc <- base64enc::base64encode(paste(guid, \".zip\", sep=\"\"))\n\n    # delete the packages\n    for (pkg in packages) {\n      # did I miss anything? maybe extra files floating around\n      file.remove(paste(pkg, \"zip\", sep=\".\"))\n    }\n    # delete the dependency rdta file\n    file.remove(guid)\n    file.remove(paste(guid,\"zip\",sep=\".\"))\n\n    # return the encoded zip as a string\n    return(list(guid, zipEnc))\n  }\n  # if nothing was zipped, return false\n  else {\n    return(list(guid, \"\"))\n  }\n}\n\n\n\n################################################################\n# CONVERT FORMAT\n# Helper function to convert expected schema to API-expecting format\n################################################################\nconvert <- function(argList) {\n  form <- list()\n  for (arg in names(argList)) {\n    type = argList[[arg]]\n    # probably a better way to code this\n    if (type == \"float\" || type == \"double\") {\n      form[[ arg ]] <- list(\"type\"=\"number\", \"format\"=type)\n    }\n    else if (type == \"date-time\" || type == \"string\" || type == \"time-span\") {\n      form[[arg]] <- list(\"type\"=\"string\", \"format\"=type)\n    }\n    else if (type == \"uint16\" || type == \"int16\" || type == \"uint32\" || type == \"int32\" || type == \"uint64\" || type == \"int64\") {\n      form[[arg]] <- list(\"type\"=\"integer\", \"format\"=type)\n    }\n    else if (type == \"int\") {\n      form[[arg]] <- list(\"type\"=\"integer\", \"format\"=\"int32\")\n    }\n    else if (type == \"bool\" || type == \"boolean\") {\n      form[[arg]] <- list(\"type\"=\"boolean\")\n    }\n    else {\n      stop(sprintf(\"Error: data type \\\"%s\\\" not supported\", type), call. = TRUE)\n    }\n  }\n  return(form)\n}\n\n\n\n################################################################\n# expecting inputSchema = list(\"arg1\"=\"type\", \"arg2\"=\"type\", ...)\n# expecting outputSchema = list(\"output1\"=\"type\", \"output2\"=\"type\", ...)\n# funName is a string!!\n################################################################\n# TODO: play around with argument order\npublishWebService <- function(funName, serviceName, inputSchema, outputSchema, wkID, authToken) {\n\n  # Accept SSL certificates issued by public Certificate Authorities\n  options(RCurlOptions = list(cainfo = system.file(\"CurlSSL\", \"cacert.pem\", package = \"RCurl\")))\n\n  # Get and encode the dependencies\n  zipString = packDependencies(funName)\n\n  # Build the body of the request, differing on whether or not there is a zip to upload\n  # Probably a more elegant way to do this\n  if (zipString[[2]] == \"\") {\n    req = list(\n      \"Name\" = serviceName,\n      \"Type\" = \"Code\",\n      \"CodeBundle\" = list(\n        \"InputSchema\" = convert(inputSchema),\n        \"OutputSchema\" = convert(outputSchema),\n        \"Language\" = \"r-3.1-64\",\n        \"SourceCode\" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(funName)))\n\n      )\n    )\n  }\n  else {\n    req = list(\n      \"Name\" = serviceName,\n      \"Type\" = \"Code\",\n      \"CodeBundle\" = list(\n        \"InputSchema\" = format(inputSchema),\n        \"OutputSchema\" = format(outputSchema),\n        \"Language\" = \"r-3.1-64\",\n        \"SourceCode\" = sprintf(wrapper, length(outputSchema), zipString[[1]], zipString[[1]], paste(getFunctionString(funName))),\n#        \"SourceCode\" = \"inputDF <- maml.mapInputPort(1)\\r\\ninstall.packages(paste(\\\"src\\\", \\\"codetools.zip\\\", sep=\\\"/\\\"), lib = \\\".\\\", repos=NULL)\\r\\nlibrary(\\\"codetools\\\")\\r\\noutputDF <- data.frame(findGlobals(findGlobals))\\r\\nmaml.mapOutputPort(\\\"outputDF\\\")\",\n#        \"SourceCode\" = \"inputDF <- maml.mapInputPort(1)\\r\\noutputDF <- data.frame(list.files(\\\"src\\\"))\\r\\nmaml.mapOutputPort(\\\"outputDF\\\")\",\n        \"ZipContents\" = zipString[[2]]\n      )\n    )\n  }\n\n  # convert the payload to JSON as expected by API\n  # TODO: consolidate json packages, i.e. use only one if possible\n  body = RJSONIO::toJSON(req)\n\n  # Response gatherer\n  h = RCurl::basicTextGatherer()\n  h$reset()\n\n  # Generate unique guid\n  guid = gsub(\"-\", \"\", uuid::UUIDgenerate(use.time=TRUE))\n\n  # API call\n  RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above\n                 httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),\n                          'Content-Type' = 'application/json',\n                          'Accept' = 'application/json'),\n                 content = body,\n                 writefunction = h$update,\n                 ssl.verifyhost = FALSE) ### REMOVE THIS FOR THE REAL VERSION ###\n\n  # return everything\n  # TODO: format output\n  rjson::fromJSON(h$value())\n}\n",
    "created" : 1432925929555.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "60|1|120|0|\n",
    "hash" : "673865319",
    "id" : "963CCB12",
    "lastKnownWriteTime" : 1435788752,
    "path" : "~/Azure-MachineLearning-ClientLibrary-R/maml/R/publish.R",
    "project_path" : "R/publish.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}