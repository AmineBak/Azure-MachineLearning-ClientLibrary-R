{
    "contents" : "# String constants --------------------------------------------------------\n\npublishURL <- \"https://management.azureml.net/workspaces/%s/webservices/%s\"\nwrapper <- \"inputDF <- maml.mapInputPort(1)\\r\\noutputDF <- matrix(ncol = %s, nrow = nrow(inputDF))\\r\\ncolnames(outputDF) <- list(%s)\\r\\noutputDF <- data.frame(outputDF)\\r\\nfor (file in list.files(\\\"src\\\")) {\\r\\n  if (file == \\\"%s\\\") {\\r\\n    load(\\\"src/%s\\\")\\r\\n    for (item in names(dependencies)) {\\r\\n      assign(item, dependencies[[item]])\\r\\n    }\\r\\n  }\\r\\n  else {\\r\\n    if (!(file %%in%% installed.packages()[,\\\"Package\\\"])) {\\r\\n      install.packages(paste(\\\"src\\\", file, sep=\\\"/\\\"), lib=\\\".\\\", repos=NULL, verbose=TRUE)\\r\\n    }\\r\\n    library(strsplit(file, \\\"\\\\\\\\.\\\")[[1]][[1]], character.only=TRUE)\\r\\n  }\\r\\n}\\r\\naction <- %s\\r\\nfor (i in 1:nrow(inputDF)) {\\r\\n  outputDF[i,] <- do.call(\\\"action\\\", as.list(inputDF[i,]))\\r\\n}\\r\\nmaml.mapOutputPort(\\\"outputDF\\\")\"\n\n# Functions ---------------------------------------------------------------\n\n#' Get function source code\n#'\n#' Returns the source code of a function as a string\n#'\n#' @param x name of the function to convert to a string\n#' @return source code of the function as a string\n#'\n#' @keywords internal\ngetFunctionString <- function (x)\n{\n  if (tryCatch(!is.character(x), error = function(e) TRUE))\n    x <- as.character(substitute(x))\n  objs <- list()\n  where <- character()\n  visible <- logical()\n  if (length(pos <- find(x, numeric = TRUE))) {\n    objs <- lapply(pos, function(pos, x) get(x, pos = pos),\n                   x = x)\n    where <- names(pos)\n    visible <- rep.int(TRUE, length(pos))\n  }\n  if (length(grep(\".\", x, fixed = TRUE))) {\n    np <- length(parts <- strsplit(x, \".\", fixed = TRUE)[[1L]])\n    for (i in 2:np) {\n      gen <- paste(parts[1L:(i - 1)], collapse = \".\")\n      cl <- paste(parts[i:np], collapse = \".\")\n      if (gen == \"\" || cl == \"\")\n        next\n      Call <- substitute(getS3method(gen, cl, TRUE), list(gen = gen,\n                                                          cl = cl))\n      f <- eval.parent(Call)\n      if (!is.null(f) && !is.null(environment(f))) {\n        ev <- topenv(environment(f), baseenv())\n        nmev <- if (isNamespace(ev))\n          getNamespaceName(ev)\n        else NULL\n        objs <- c(objs, f)\n        msg <- paste(\"registered S3 method for\", gen)\n        if (!is.null(nmev))\n          msg <- paste(msg, \"from namespace\", nmev)\n        where <- c(where, msg)\n        visible <- c(visible, FALSE)\n      }\n    }\n  }\n  for (i in loadedNamespaces()) {\n    ns <- asNamespace(i)\n    if (exists(x, envir = ns, inherits = FALSE)) {\n      f <- get(x, envir = ns, inherits = FALSE)\n      objs <- c(objs, f)\n      where <- c(where, paste(\"namespace\", i, sep = \":\"))\n      visible <- c(visible, FALSE)\n    }\n  }\n  ln <- length(objs)\n  dups <- rep.int(FALSE, ln)\n  if (ln > 1L)\n    for (i in 2L:ln) for (j in 1L:(i - 1L)) if (identical(objs[[i]],\n                                                          objs[[j]], ignore.environment = TRUE)) {\n      dups[i] <- TRUE\n      break\n    }\n  res <- list(name = x, objs = objs, where = where, visible = visible,\n              dups = dups)\n  class(res) <- \"getAnywhere\"\n\n  #don't show the full response!\n  #res\n  # Might return multiple objects in a list if multiple functions with the same name\n  return(gsub(\"\\n\", \"\\r\\n\", gsub(\"\\\"\", \"\\\\\\\"\", objs[1])))\n}\n\n\n\n#' Package a function's dependencies into a base64 encoded string\n#'\n#' Find a function's in-memory and package dependencies, and turn them into a base-64 encoded zip file. This string is used in the publish API call to upload dependencies to the server.\n#'\n#' @param functionName function to package dependencies from\n#' @return list containing the guid for the rdta file and the encoded zip\n#'\n#' @keywords internal\npackDependencies <- function(functionName) {\n\n  # Recursive step for package packaging\n  recurPkg <- function(pkgName, pkgList) {\n    # if the package isn't already in the list\n    if (!(pkgName %in% pkgList)) {\n      # add it\n      pkgList <- c(pkgName, pkgList)\n\n      # if the package is available on a repo\n      if (pkgName %in% row.names(available.packages())) {\n        # iterate through the dependencies and check if need to add them\n        for (pkg in strsplit(available.packages()[pkgName, \"Depends\"], split=\", \")[[1]]) {\n          # filter out duplicates, R version dependencies, and base packages\n          if (!(pkg %in% pkgList) && !(grepl(\"R \\\\((.*)\\\\)\", pkg)) && (pkg %in% row.names(available.packages()))) {\n            # recursively call recurPkg\n            pkgList <- recurPkg(pkg, pkgList)\n          }\n        }\n        # iterate through imports\n        for (pkg in strsplit(available.packages()[pkgName, \"Imports\"], split=\", \")[[1]]) {\n          # filter out duplicates, R version dependencies, and base packages\n          if (!(pkg %in% pkgList) && !(grepl(\"R \\\\((.*)\\\\)\", pkg)) && (pkg %in% row.names(available.packages()))) {\n            # recursively call recurPkg\n            pkgList <- recurPkg(pkg, pkgList)\n          }\n        }\n      }\n    }\n    # return updated list of packages\n    return(pkgList)\n  }\n\n  # Recursive step for object packaging\n  # NOTE: will not work if the user function specifies the names directly, e.g. won't find rjson::toJSON\n  # from findGlobals man page: \"R semantics only allow variables that might be local to be identified\"\n  recurDep <- function(objName, depList, pkgList) {\n    # findGlobals() gets all external dependencies\n    # Iterate over them\n    for (obj in codetools::findGlobals(get(objName))) {\n      name = get(obj)\n\n      # filter out primitives and duplicates\n      if (is.primitive(name) || (obj %in% names(depList))) {\n        next\n      }\n      # non-function object dependencies\n      else if (!is.function(name)) {\n        depList[[obj]] <- name\n\n        # Use the object's class to find package dependencies\n        objClass <- class(name)\n\n        # iterate through the class vector looking for packages\n        for (class in objClass) {\n          tryCatch({\n            # get the name of the package the class belongs to\n            nameEnv <- environment(get(class))\n            # filter out basic environment\n            if (!(identical(nameEnv, NULL)) && !(identical(nameEnv, .BaseNamespaceEnv))) {\n              pkgList <- recurPkg(paste(getNamespaceName(nameEnv)), pkgList)\n            }\n          # if unable to find package, continue\n          }, error = function(e) {\n            sprintf(\"%s not found\", obj)\n          })\n        }\n      }\n      # user defined functions\n      else if (identical(environment(name), globalenv())) {\n        depList[[obj]] <- name\n        results <- recurDep(obj, depList, pkgList)\n        depList <- results$dependencies\n        pkgList <- results$packages\n      }\n      # functions from packages\n      else if (paste(getNamespaceName(environment(name))) != \"base\") {\n        pkgList <- recurPkg(paste(getNamespaceName(environment(name))), pkgList)\n      }\n    }\n    return(list(\"dependencies\"=depList, \"packages\"=pkgList))\n  }\n\n  # call recurDep on the desired function and with empty lists\n  results <- recurDep(functionName, list(), list())\n  dependencies <- results$dependencies\n  packages <- results$packages\n\n  # save current path to restore later\n  start = getwd()\n  # go to package library, doing this to prevent zipping entire path to package\n  toPack <- packages\n  toZip = vector()\n  for (i in 1:length(.libPaths())) {\n    setwd(.libPaths()[i])\n    # try to find the package in the directory and zip it\n    for (pkg in toPack) {\n      if (file.exists(pkg)) {\n        # save it to original directory\n        zip(paste(start, paste(pkg, \"zip\", sep=\".\"), sep=\"/\"), pkg)\n        toZip <- c(toZip, paste(pkg, \"zip\", sep=\".\"))\n        # remove the package from the list of packages to pack\n        toPack <- toPack[toPack != pkg]\n      }\n    }\n\n    # if done packing, break\n    if (length(toPack) == 0) {\n      break\n    }\n  }\n\n  # go back to where the user started\n  setwd(start)\n\n  # make sure that all packages were found\n  if (length(toPack) > 0) {\n    stop(\"Error: unable to locate one or more packages. Please make sure the packages used are in at least one of the library paths.\")\n  }\n\n  # generate a GUID to act as a file name to store packages, R data\n  guid = gsub(\"-\", \"\", uuid::UUIDgenerate(use.time=TRUE))\n  # dump objects, functions, etc. into .rdta file\n  if (length(dependencies) > 0) {\n    # maybe can save directly as a .zip and skip the zip() call?\n    save(dependencies, file=guid)\n    toZip <- c(toZip, guid)\n  }\n\n  # zip up everything\n  if (length(toZip) > 0) {\n    zip(zipfile=guid, files=toZip)\n    zipEnc <- base64enc::base64encode(paste(guid, \".zip\", sep=\"\"))\n\n    # delete the packages\n    for (pkg in packages) {\n      file.remove(paste(pkg, \"zip\", sep=\".\"))\n    }\n\n    # delete the dependency rdta file\n    if (length(dependencies) > 0) {\n      file.remove(guid)\n      file.remove(paste(guid,\"zip\",sep=\".\"))\n    }\n\n    # return the encoded zip as a string\n    return(list(guid, zipEnc))\n    #return(list(guid))\n  }\n\n  # if nothing was zipped, return empty string to indicate\n  # returning two things because unable to return variable amounts\n  else {\n    return(list(guid, \"\"))\n  }\n}\n\n\n\n#' Convert input schema to API expected format.\n#'\n#' Helper function to convert the user-friendly input and output schema parameters to the publishWebService() function to the format expected by the API.\n#'\n#' @param argList list of expected input parameters in the format expected by \\code{\\link{publishWebService}}\n#' @return list of the format expected by the API\n#'\n#' @keywords internal\npublishPreprocess <- function(argList) {\n  form <- list()\n  for (arg in names(argList)) {\n    type = argList[[arg]]\n\n    if (type == \"float\" || type == \"double\") {\n      form[[ arg ]] <- list(\"type\"=\"number\", \"format\"=type)\n    }\n    else if (type == \"date-time\" || type == \"string\" || type == \"time-span\") {\n      form[[arg]] <- list(\"type\"=\"string\", \"format\"=type)\n    }\n    else if (type == \"uint16\" || type == \"int16\" || type == \"uint32\" || type == \"int32\" || type == \"uint64\" || type == \"int64\") {\n      form[[arg]] <- list(\"type\"=\"integer\", \"format\"=type)\n    }\n    else if (type == \"int\") {\n      form[[arg]] <- list(\"type\"=\"integer\", \"format\"=\"int32\")\n    }\n    else if (type == \"bool\" || type == \"boolean\") {\n      form[[arg]] <- list(\"type\"=\"boolean\")\n    }\n    else {\n      stop(sprintf(\"Error: data type \\\"%s\\\" not supported\", type), call. = TRUE)\n    }\n  }\n  return(form)\n}\n\n\n\n#' Publish a function to Microsoft Azure\n#'\n#' Publish a function to Microsoft Azure as a web service. The web service can then be consumed within R, Visual Studio, Excel, etc. as long as the user has the API key and location. The function to be published can use arbitrary objects and packages. Currently, the function to be published can only take in primitive data types as input, i.e. no data frames or lists, but support for those functions will be added in the future.\n#'\n#' @export\n#'\n#' @param functionName function name as a string to be published\n#' @param serviceName name of the new web service\n#' @param inputSchema list of input parameters of format \\code{list(\"arg1\"=\"type\", \"arg2\"=\"type\", ...)}\n#' @param outputSchema list of outputs of format \\code{list(\"output1\"=\"type\", \"output2\"=\"type\", ...)}\n#' @param wkID the workspace ID\n#' @param authToken primary authorization token\n#' @return nested list, the first element is a list containing information about the new web service, the second element is a list of its endpoints\n#'\n#' @family publishing functions\n#' @examples\n#' \\dontrun{\n#' add <- function(x,y) { return(x+y) }\n#' newService <- publishWebService(\"add\", \"add\",\n#'  list(\"x\"=\"int\",\"y\"=\"int\"), list(\"z\"=\"int\"), wsID, authToken)\n#' webserviceDetails <- newService[[1]]\n#' endpoints <- newService[[2]]\n#' }\npublishWebService <- function(functionName, serviceName, inputSchema, outputSchema, wkID, authToken) {\n\n  # Make sure schema inputted matches function signature\n  if (length(formals(functionName)) != length(inputSchema)) {\n    stop(sprintf(\"Input schema does not contain the proper input. You provided %s inputs and %s were expected\",length(inputSchema),length(formals(functionName))), call. = TRUE)\n  }\n  inputSchema <- publishPreprocess(inputSchema)\n  outputSchema <- publishPreprocess(outputSchema)\n\n  # Accept SSL certificates issued by public Certificate Authorities\n  options(RCurlOptions = list(cainfo = system.file(\"CurlSSL\", \"cacert.pem\", package = \"RCurl\")))\n\n  # Get and encode the dependencies\n  zipString = packDependencies(functionName)\n\n  # Build the body of the request, differing on whether or not there is a zip to upload\n  if (zipString[[2]] == \"\") {\n    req = list(\n      \"Name\" = serviceName,\n      \"Type\" = \"Code\",\n      \"CodeBundle\" = list(\n        \"InputSchema\" = inputSchema,\n        \"OutputSchema\" = outputSchema,\n        \"Language\" = \"r-3.1-64\",\n        \"SourceCode\" = sprintf(wrapper, length(outputSchema), paste(sprintf(\"\\\"%s\\\"\", names(outputSchema)), collapse=\",\"), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))\n      )\n    )\n  }\n  else {\n    req = list(\n      \"Name\" = serviceName,\n      \"Type\" = \"Code\",\n      \"CodeBundle\" = list(\n        \"InputSchema\" = inputSchema,\n        \"OutputSchema\" = outputSchema,\n        \"Language\" = \"r-3.1-64\",\n        \"SourceCode\" = sprintf(wrapper, length(outputSchema), paste(sprintf(\"\\\"%s\\\"\", names(outputSchema)), collapse=\",\"), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),\n        \"ZipContents\" = zipString[[2]]\n      )\n    )\n  }\n\n\n  # convert the payload to JSON as expected by API\n  body = rjson::toJSON(req)\n\n  # Response gatherer\n  h = RCurl::basicTextGatherer()\n  h$reset()\n\n  # Generate unique guid to serve as the web service ID\n  guid = gsub(\"-\", \"\", uuid::UUIDgenerate(use.time=TRUE))\n\n  # API call\n  RCurl::httpPUT(url = sprintf(publishURL, wkID, guid), # defined above\n                 httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),\n                              'Content-Type' = 'application/json',\n                              'Accept' = 'application/json'),\n                 content = body,\n                 writefunction = h$update)\n\n  # Format output\n  newService <- rjson::fromJSON(h$value())\n  print(newService)\n\n  # Use discovery functions to get endpoints for immediate use\n  endpoints <- getEndpoints(wkID, authToken, newService[\"Id\"])\n\n  # currently returning list of webservice details (as a list) and endpoint details (as a list) in that order\n  return(list(\"serviceDetails\"=newService, \"endpoints\"=endpoints))\n}\n\n\n\n#' Update a Published Web Service\n#'\n#' Update a web service, i.e. change the underlying R code that the service will run when called.\n#'\n#' @export\n#'\n#' @inheritParams publishWebService\n#' @param wsID ID of the web service to be updated\n#' @return List of webservice details, default endpoint details, and the consumption function\n#'\n#' @family publishing functions\n#'\n#' @examples\n#' \\dontrun{\n#' add1 <- function(x) { return(x+1) }\n#' addService <- publishWebService(\"add1\", \"add1\",\n#'  list(\"x\"=\"int\"), list(\"z\"=\"int\"), wsID, wsAuth)\n#'\n#' add2 <- function(x) { return(x+2) }\n#' addService <- updateWebService(\"add2\", \"add2\", addService[[1]]$Id,\n#'  list(\"x\"=\"int\"), list(\"z\"=\"int\"), wsID, wsAuth)\n#' }\nupdateWebService <- function(functionName, serviceName, wsID, inputSchema, outputSchema, wkID, authToken) {\n\n  # Make sure schema inputted matches function signature\n  if (length(formals(functionName)) != length(inputSchema)) {\n    stop(sprintf(\"Input schema does not contain the proper input. You provided %s inputs and %s were expected\",length(inputSchema),length(formals(functionName))), call. = TRUE)\n  }\n  inputSchema <- publishPreprocess(inputSchema)\n  outputSchema <- publishPreprocess(outputSchema)\n\n  # Accept SSL certificates issued by public Certificate Authorities\n  options(RCurlOptions = list(cainfo = system.file(\"CurlSSL\", \"cacert.pem\", package = \"RCurl\")))\n\n  # Get and encode the dependencies\n  zipString = packDependencies(functionName)\n\n  # Build the body of the request, differing on whether or not there is a zip to upload\n  if (zipString[[2]] == \"\") {\n    req = list(\n      \"Name\" = serviceName,\n      \"Type\" = \"Code\",\n      \"CodeBundle\" = list(\n        \"InputSchema\" = inputSchema,\n        \"OutputSchema\" = outputSchema,\n        \"Language\" = \"r-3.1-64\",\n        \"SourceCode\" = sprintf(wrapper, length(outputSchema), paste(sprintf(\"\\\"%s\\\"\", names(outputSchema)), collapse=\",\"), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName)))\n      )\n    )\n  }\n  else {\n    req = list(\n      \"Name\" = serviceName,\n      \"Type\" = \"Code\",\n      \"CodeBundle\" = list(\n        \"InputSchema\" = inputSchema,\n        \"OutputSchema\" = outputSchema,\n        \"Language\" = \"r-3.1-64\",\n        \"SourceCode\" = sprintf(wrapper, length(outputSchema), paste(sprintf(\"\\\"%s\\\"\", names(outputSchema)), collapse=\",\"), zipString[[1]], zipString[[1]], paste(getFunctionString(functionName))),\n        \"ZipContents\" = zipString[[2]]\n      )\n    )\n  }\n\n  # convert the payload to JSON as expected by API\n  # TODO: consolidate json packages, i.e. use only one if possible\n  body = rjson::toJSON(req)\n\n  # Response gatherer\n  h = RCurl::basicTextGatherer()\n  h$reset()\n\n  # API call\n  RCurl::httpPUT(url = sprintf(publishURL, wkID, wsID),\n                 httpheader=c('Authorization' = paste('Bearer', authToken, sep=' '),\n                              'Content-Type' = 'application/json',\n                              'Accept' = 'application/json'),\n                 content = body,\n                 writefunction = h$update)\n\n  # Format output\n  updatedService <- rjson::fromJSON(h$value())\n\n  # Use discovery functions to get default endpoint for immediate use\n  endpoints <- getEndpoints(wkID, authToken, updatedService[\"Id\"])\n\n  return(list(\"serviceDetails\"=updatedService, \"endpoints\"=endpoints))\n}\n",
    "created" : 1438637415994.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "258245759",
    "id" : "30C3E25F",
    "lastKnownWriteTime" : 1438978927,
    "path" : "~/Azure-MachineLearning-ClientLibrary-R/AzureML/R/publish.R",
    "project_path" : "R/publish.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}