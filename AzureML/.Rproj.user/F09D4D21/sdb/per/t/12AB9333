{
    "contents" : "#' Discover web service schema\n#'\n#' Discover the expected input to a web service specified by a web service ID ng the workspace ID and web service ID, information specific to the consumption functions\n#'\n#' @export\n#'\n#' @param helpURL URL of the help page of the web service\n#' @param scheme the URI scheme\n#' @param host optional parameter that defaults to ussouthcentral.services.azureml.net\n#' @param api_version defaults to 2.0\n#' @return List containing the request URL of the webservice, column names of the data, sample input as well as the input schema\n#'\n#' @family consumption functions\n#'\n#' @examples\n#' \\dontrun{\n#' endpoints <- getEndpoints(\"wsID\", \"wsAuth\", \"webserviceID\")\n#' wsSchema <- discoverSchema(endpoints[[1]]$HelpLocation)\n#' }\ndiscoverSchema <- function(helpURL, scheme = \"https\", host = \"ussouthcentral.services.azureml.net\", api_version = \"2.0\") {\n  endpointId = getDetailsFromUrl(helpURL)[[1]]\n  workspaceId = getDetailsFromUrl(helpURL)[[2]]\n  # Construct swagger document URL using parameters\n  # Use paste method without separator\n  swaggerURL = paste(scheme,\"://\", host, \"/workspaces/\", workspaceId, \"/services/\", endpointId,\"/swagger.json\", sep = \"\")\n  print(swaggerURL)\n\n  # Automatically parses the content and gets the swagger document\n\n  response <- RCurl::getURLContent(swaggerURL)\n  swagger = rjson::fromJSON(response)\n\n  # Accesses the input schema in the swagger document\n  inputSchema = swagger$definition$input1Item\n  #Accesses the example in the swagger document and converts it to JSON\n  exampleJson <- rjson::toJSON(swagger$definitions$ExecutionRequest$example)\n\n  #Accesses a single specific JSON object and formats it to be a request inputted as a list in R\n  inputExample = as.list((jsonlite::fromJSON((exampleJson)))$Inputs$input1)\n\n  for(i in 1:length(inputExample)) {\n    if(typeof(inputExample[[i]]) == \"character\") {\n      inputExample[i] = \"Please input valid String\"\n    }\n  }\n  #Accesses the names of the columns in the example and stores it in a list of column names\n  columnNames = list()\n  for(i in 1:length(inputExample)) {\n    columnNames[[i]] = names(inputExample)[[i]]\n  }\n  # Uses multiple nested loops to access the various paths in the swagger document and find the execution path\n  foundExecPath = FALSE\n  pathNo = 0\n  execPathNo= -1\n  for(execPath in swagger$paths) {\n    pathNo = pathNo + 1\n    for(operationpath in execPath) {\n      for(operation in operationpath) {\n        #Goes through the characteristcs in every operation e.g. operationId\n        for(charac in operation) {\n          # Finds the path in which the operationId (characteristic of the path) = execute and sets the execution path number\n          if(charac[1] == \"execute\")\n          {\n            #Sets found execution path to true\n            foundExecPath = TRUE\n            execPathNo = pathNo\n            break\n          }\n        }\n      }\n    }\n  }\n\n  #Stores the execution path\n  if(foundExecPath) {\n    executePath = names(swagger$paths)[[execPathNo]]\n  } else{\n    executePath = \"Path not found\"\n  }\n  # Constructs the request URL with the parameters as well as execution path found. The separator is set to an empty string\n  requestUrl = paste(scheme,\"://\", host, \"/workspaces/\", workspaceId, \"/services/\", endpointId, executePath, sep = \"\")\n\n  # Access the HTTP method type e.g. GET/ POST and constructs an example request\n  httpMethod = toupper(names(swagger$paths[[2]]))\n  httpRequest = paste(httpMethod,requestUrl)\n  # Tell user what functions they can use and prints to the console\n  if(foundExecPath) {\n    consumeFile = paste(\"To score a file: consumeFile(apiKey, requestUrl, dataframe)\")\n    consumeDataFrame = paste(\"To score a dataframe: consumeDataframe(apiKey, requestUrl, scoreDataFrame)\")\n    consumeLists = paste(\"To score requests as lists in the key-value format: consumeLists(apiKey, requestUrl, ...)\")\n    cat(\"Sample functions to execute the web service and get a response synchronously:\",\"\\n\", consumeFile,\"\\n\", consumeDataFrame,\"\\n\", consumeLists,\"\\n\",\"\\n\")\n\n  } else {\n    cat(\"Warning! There was no execution path found for this web service, hence a request URL cannot be constructed!\",\"\\n\",\"\\n\")\n  }\n  # Warns user of characters and urges them to enter valid strings for them\n  firstWarning = TRUE\n  for(i in 1:length(inputExample)) {\n    if(typeof(inputExample[[i]]) == \"character\") {\n      if(firstWarning) {\n        cat(\"Warning! The sample input does not contain sample values for characters. Please input valid Strings for these fields\", \"\\n\")\n      }\n      cat(\"   \", names(inputExample)[[i]],\"\\n\")\n      firstWarning = FALSE\n    }\n  }\n\n  #Returns what was discovered in the form of a list\n  return (list(\"requestUrl\" = requestUrl, \"columnNames\" = columnNames, \"sampleInput\" = inputExample, \"inputSchema\" = inputSchema))\n}\n\n#' Use a web service to score a file\n#'\n#' Read in a csv and score it in batches using a Microsoft Azure Machine Learning Web Service. The results are stored in a new csv, default named \"results.csv\"\n#'\n#' @export\n#'\n#' @param apiKey primary access key as a string\n#' @param requestUrl API URL\n#' @param inFileName the name of the file to be scored as a string\n#' @param globalParam global parameters entered as a list, default value is an empty list\n#' @param outputFileName the name of the file to output results to, entered as a string, default value is \"results.csv\"\n#' @param batchSize batch size of each batch, default value is 300\n#' @param retryDelay the time in seconds to delay before retrying in case of a server error, default value is 0.3 seconds\n#' @return returnDataFrame data frame containing results returned from web service call\n#'\n#' @family consumption functions\n#'\n#' @examples\n#' \\dontrun{\n#' add <- function(x,y) { return(x+y) }\n#' newService <- publishWebService(\"add\", \"add\",\n#'  list(\"x\"=\"int\",\"y\"=\"int\"), list(\"z\"=\"int\"), wsID, authToken)\n#' webserviceDetails <- newService[[1]]\n#' endpoints <- newService[[2]]\n#'\n#' response <- consumeFile(endpoints[[1]]$PrimaryKey, endpoints[[1]]$ApiLocation, \"test.csv\")\n#' }\nconsumeFile <- function(apiKey, requestUrl, inFileName, globalParam = setNames(list(), character(0)), outputFileName = \"results.csv\", batchSize = 300, retryDelay = 0.3) {\n  #Stops users if they miss out mandatory fields\n  if (missing(apiKey)) {\n    stop(\"Need to specify API key\")\n  }\n  if (missing(inFileName)) {\n    stop(\"Need to specify file to be scored\")\n  }\n  if (missing(requestUrl)) {\n    stop(\"Need to specify request URL\")\n  }\n  #read file and store as a data frame to be scored\n  scoreDataFrame = read.csv(inFileName,check.names=FALSE)\n  # create empty data frame that stores results to be returned\n  returnDataFrame <- data.frame(stringsAsFactors=FALSE)\n  # create data frame that stores requests in each batch\n  requestBatch = data.frame(stringsAsFactors=FALSE)\n  counter = 1\n  lastProc = 0\n\n  # Loop that iterates through the rows of the entire data frame that is to be scored\n  for(i in 1:(nrow(scoreDataFrame))) {\n    # If we have reached the batch size provided or the end of the data frame\n    if(counter == batchSize || i == (nrow(scoreDataFrame))) {\n      # Create empty data frame that stores results for that batch\n      batchResults = data.frame(stringsAsFactors=FALSE)\n      # Store a single batch of requests in a data frame\n      requestBatch = scoreDataFrame[(lastProc+1):i,]\n      # Convert them into key-value lists using rjson and df2json packages\n      keyvalues = rjson::fromJSON((df2json::df2json(requestBatch)))\n      # Store results returned from call in temp variable\n      temp <- callAPI(apiKey, requestUrl, keyvalues, globalParam, retryDelay)\n      # Set last processed to current row\n      lastProc = i\n      # Access output by converting from JSON into list and indexing into Results\n      resultStored <- jsonlite::fromJSON(temp)\n      resultList = resultStored$Results$output1\n      batchResults <- data.frame(resultList)\n      # Force returnDataFrame to have the same column names to avoid errors\n      if(length(returnDataFrame) != 0 && length(batchResults) != 0) {\n        names(returnDataFrame) <- names(resultList)\n      }\n      #Add batch results to the dataframe to be returned\n      returnDataFrame <- rbind(returnDataFrame,batchResults)\n      #Print how many rows in total have been processed\n      print(sprintf(\"%i %s %i %s\", i,\"out of\",nrow(scoreDataFrame),\"processed\"))\n      #Reset the requests in the batch to empty data frame\n      requestBatch = data.frame(stringsAsFactors=FALSE)\n      counter = 0\n    }\n    counter = counter + 1\n  }\n\n  # Write results to a csv file\n  resultsFile <-file(outputFileName,\"w\")\n  write.csv(returnDataFrame, resultsFile)\n  close(resultsFile)\n  return (returnDataFrame)\n}\n\n#' Use a web service to score data in list format\n#'\n#' Score data represented as lists, where each list represents one parameter of the web service\n#'\n#' @export\n#'\n#' @param apiKey primary access key as a string\n#' @param requestUrl API URL\n#' @param ... variable number of requests entered as lists in key-value format\n#' @param globalParam global parameters entered as a list, default value is an empty list\n#' @param retryDelay the time in seconds to delay before retrying in case of a server error, default value is 0.3 seconds\n#' @return returnDataFrame data frame containing results returned from web service call\n#'\n#' @family consumption functions\n#' @examples\n#' \\dontrun{\n#' add <- function(x,y) { return(x+y) }\n#' newService <- publishWebService(\"add\", \"add\",\n#'  list(\"x\"=\"int\",\"y\"=\"int\"), list(\"z\"=\"int\"), wsID, authToken)\n#' webserviceDetails <- newService[[1]]\n#' endpoints <- newService[[2]]\n#'\n#' response <- consumeLists(endpoints[[1]]$PrimaryKey, endpoints[[1]]$ApiLocation,\n#'  list(\"x\"=1, \"y\"=2), list(\"x\"=3, \"y\"=4))\n#' }\nconsumeLists <- function(apiKey, requestUrl, ..., globalParam = setNames(list(), character(0)), retryDelay = 0.3) {\n  #Stops users if they miss out mandatory fields\n\n  if (missing(apiKey)) {\n    stop(\"Need to specify API key\")\n  }\n\n  if (missing(requestUrl)) {\n    stop(\"Need to specify request URL\")\n  }\n  if(missing(globalParam)) {\n    globalParam = setNames(list(), character(0))\n  }\n  # Store variable number of lists entered as a list of lists\n  requestsLists <- list(...)\n  # Make API call with parameters\n  result <- callAPI(apiKey, requestUrl, requestsLists,  globalParam, retryDelay)\n  # Access output by converting from JSON into list and indexing into Results\n  resultStored <- jsonlite::fromJSON(result)\n  resultList = resultStored$Results$output1\n\n  # Store results in a data frame\n  resultDataFrame <- data.frame(resultList)\n\n  return(resultDataFrame)\n}\n\n#' Use a web service to score a data frame\n#'\n#' Score a data frame, where each row is the input to the scoring function, using a Microsoft Azure Machine Learning web service\n#'\n#' @export\n#'\n#' @param apiKey primary access key of the web service as a string\n#' @param requestUrl API URL\n#' @param scoreDataFrame the data frame to be scored\n#' @param globalParam global parameters entered as a list, default value is an empty list\n#' @param batchSize batch size of each batch, default value is 300\n#' @param retryDelay the time in seconds to delay before retrying in case of a server error, default value is 0.3 seconds\n#' @return returnDataFrame data frame containing results returned from web service call\n#'\n#' @family consumption functions\n#' @examples\n#' \\dontrun{\n#' add <- function(x,y) { return(x+y) }\n#' newService <- publishWebService(\"add\", \"add\",\n#'  list(\"x\"=\"int\",\"y\"=\"int\"), list(\"z\"=\"int\"), wsID, authToken)\n#' webserviceDetails <- newService[[1]]\n#' endpoints <- newService[[2]]\n#'\n#' df <- data.frame(\"x\"=c(1,2), \"y\"=c(3,4))\n#' response <- consumeDataframe(endpoints[[1]]$PrimaryKey, endpoints[[1]]$ApiLocation, df)\n#' }\nconsumeDataframe <- function(apiKey, requestUrl, scoreDataFrame, globalParam=setNames(list(), character(0)), batchSize = 300, retryDelay = 0.3) {\n  #Stops users if they miss out mandatory fields\n\n  if (missing(apiKey)) {\n    stop(\"Need to specify API key\")\n  }\n\n  if (missing(requestUrl)) {\n    stop(\"Need to specify request URL\")\n  }\n  if (missing(scoreDataFrame)) {\n    stop(\"Need to specify dataframe to be scored\")\n  }\n\n  # create empty data frame that stores results to be returned\n  returnDataFrame <- data.frame(stringsAsFactors=FALSE)\n  # create data frame that stores requests in each batch\n  requestBatch = data.frame(stringsAsFactors=FALSE)\n  counter = 1\n  lastProc = 0\n\n  # Loop that iterates through the rows of the entire data frame that is to be scored\n  for(i in 1:(nrow(scoreDataFrame))) {\n    # If we have reached the batch size provided or the end of the data frame\n    if(counter == batchSize || i == (nrow(scoreDataFrame))) {\n      # Create empty data frame that stores results for that batch\n      batchResults = data.frame(stringsAsFactors=FALSE)\n      # Store a single batch of requests in a data frame\n      requestBatch = scoreDataFrame[(lastProc+1):i,]\n      # Convert them into key-value lists using rjson and df2json packages\n      keyvalues = rjson::fromJSON((df2json::df2json(requestBatch)))\n      # Store results returned from call in temp variable\n      temp <- callAPI(apiKey, requestUrl, keyvalues, globalParam, retryDelay)\n      # Set last processed to current row\n      lastProc = i\n      # Access output by converting from JSON into list and indexing into Results\n      resultStored <- jsonlite::fromJSON(temp)\n      resultList = resultStored$Results$output1\n      batchResults <- data.frame(resultList)\n      # Force returnDataFrame to have the same column names to avoid errors\n      if(length(returnDataFrame) != 0 && length(batchResults) != 0) {\n        names(returnDataFrame) <- names(resultList)\n      }\n      #Add batch results to the dataframe to be returned\n      returnDataFrame <- rbind(returnDataFrame,batchResults)\n      #Print how many rows in total have been processed\n      print(sprintf(\"%i %s %i %s\", i,\"out of\",nrow(scoreDataFrame),\"processed\"))\n      #Reset the requests in the batch to empty data frame\n      requestBatch = data.frame(stringsAsFactors=FALSE)\n      counter = 0\n    }\n    counter = counter + 1\n  }\n  return(returnDataFrame)\n}\n\n\n#' Framework for making a MAML web service API call.\n#'\n#' Helper function that constructs and send the API call to a Microsoft Azure Machine Learning web service, then receives and returns the response in JSON format.\n#'\n#' @param apiKey primary API key\n#' @param requestUrl API URL\n#' @param keyvalues the data to be passed to the web service\n#' @param globalParam the global parameters for the web service\n#' @param retryDelay number of seconds to wait after failing (max 3 tries) to try again\n#' @return result the response\n#'\n#' @keywords internal\ncallAPI <- function(apiKey, requestUrl, keyvalues,  globalParam, retryDelay) {\n  # Set number of tries and HTTP status to 0\n  httpStatus = 0\n  tries = 0\n  # Limit number of API calls to 3\n  for(i in 1:3) {\n    # In case of server error or if first try,\n    if(tries == 0 || httpStatus >= 500) {\n      if(httpStatus >= 500) {\n        # Print headers and let user know you are retrying\n        print(paste(\"The request failed with status code:\", httpStatus, sep=\" \"))\n        print(\"headers:\")\n        print(headers)\n        print(sprintf(\"%s %f %s\", \"Retrying in \",retryDelay,\" seconds\"))\n        # Delay by specified time in case of server error\n        Sys.sleep(retryDelay)\n      }\n      tries = tries + 1\n      # Load RCurl package functions\n      options(RCurlOptions = list(cainfo = system.file(\"CurlSSL\", \"cacert.pem\", package = \"RCurl\")))\n      h = RCurl::basicTextGatherer()\n      hdr = RCurl::basicHeaderGatherer()\n      # Construct request payload\n      req = list(\n        Inputs = list(\n          input1 = keyvalues\n        )\n        ,GlobalParameters = globalParam\n      )\n      # Convert request payload to JSON\n      body = enc2utf8((rjson::toJSON(req)))\n      # Create authorization header\n      authz_hdr = paste('Bearer', apiKey, sep=' ')\n\n      # Make call to API with necessary components\n      h$reset()\n      RCurl::curlPerform(url = requestUrl,\n                         httpheader=c('Content-Type' = \"application/json\", 'Authorization' = authz_hdr),\n                         postfields=body,\n                         writefunction = h$update,\n                         headerfunction = hdr$update,\n                         verbose = TRUE\n     )\n      # Gather headers\n      headers = hdr$value()\n      # Get HTTP status to decide whether to throw bad request or retry, or return etc.\n      httpStatus = headers[\"status\"]\n      result = h$value()\n    }\n    # Return result if successful\n    if(httpStatus == 200) {\n      return(result)\n    }\n    #if user error, print and return error details\n    else if ((httpStatus>= 400) && (500 > httpStatus))\n    {\n      print(paste(\"The request failed with status code:\", httpStatus, sep=\" \"))\n      print(\"headers:\")\n      print(headers)\n      print(h$value())\n      return (result)\n    }\n  }\n  return(result)\n}\n\n#' Helper function to extract information from a help page URL\n#'\n#' Given a Microsoft Azure Machine Learning web service endpoint, extracts the endpoint ID and the workspace ID\n#'\n#' @param helpURL the URL of a help page\n#' @return a list containing the endpoint ID and the workspace ID\n#'\n#' @keywords internal\ngetDetailsFromUrl <- function(helpURL) {\n  #Uses a strong split to extract the endpoint ID and the workspace ID\n  return (list((strsplit(((strsplit(helpURL,\"endpoints/\"))[[1]][2]),\"/\")[[1]][[1]]),(strsplit(((strsplit(helpURL,\"/workspaces/\"))[[1]][2]),\"/\")[[1]][[1]])))\n\n}\n",
    "created" : 1438730054134.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1546489630",
    "id" : "12AB9333",
    "lastKnownWriteTime" : 1438988839,
    "path" : "~/Azure-MachineLearning-ClientLibrary-R/AzureML/R/consume.R",
    "project_path" : "R/consume.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}